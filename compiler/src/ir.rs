use crate::pretty_print::{self, PrettyFormatter, PrettyPrint};

/// The basic Datatypes present on the Device
#[derive(Debug, PartialEq, Clone)]
pub enum DataType {
    Void,
    I32,
    U32,
    I16,
    U16,
    Ptr(Box<DataType>),
    Array(Box<DataType>, u32),
}

/// A simple Constant Value
#[derive(Debug, PartialEq)]
pub enum Value {
    I32(i32),
    U32(u32),
    Short(i16),
    UShort(u16),
}

/// The Operations that can be Performed on
/// the Calculator using the Operation-Expression
#[derive(Debug, PartialEq)]
pub enum OP {
    /// Represents Addition
    Add,
    /// Represents Substraction
    Substract,
    /// Represents Multiplication
    Multiply,
    /// Represents Division
    Divide,
}

/// This describes the way two values should
/// be compared
#[derive(Debug, PartialEq)]
pub enum Comparison {
    Equal,
    LessThan,
}

/// Represents a simple Condition where to
/// Expressions are compared using the given
/// Comparison
#[derive(Debug, PartialEq)]
pub struct Condition {
    pub left: Expression,
    pub right: Expression,
    pub comparison: Comparison,
}

#[derive(Debug, PartialEq, Clone)]
pub struct Variable {
    pub name: String,
    pub ty: DataType,
}

/// This represents some kind of Expression that will
/// evaluate to a specific Value which will be stored
/// in the Register R0
#[derive(Debug, PartialEq)]
pub enum Expression {
    /// Some form of Constant Value that won't change
    Constant(Value),
    /// The Value of some Variable in the current Scope
    Variable(Variable),
    /// The Address of some Variable in the current Scope
    Reference(Variable),
    /// Loads the Value at the address that is "generated"
    /// by the given Expression
    Dereference(Box<Expression>),
    /// (Root, Offset)
    /// The Root is the starting Address of the Array
    /// The Offset is the Index of the Element in the Array
    Indexed(Box<Expression>, Box<Expression>),
    /// Performs some kind of Mathematical or Logical Operation
    /// like Addition, Multiplication, etc.
    Operation(OP, Vec<Expression>),
    /// Calls the given Function with the given Expressions
    /// as the arguments to the Function
    Call(String, Vec<Expression>),
    /// A simple Nop, that does nothing
    Empty,
}

#[derive(Debug, PartialEq)]
pub enum Statement {
    /// Declares the existence of a Variable with the given
    /// Name and Datatype in the current Scope
    Declaration(Variable),
    /// Assigns the value generated by the Expression to the
    /// given Variable
    Assignment(Variable, Expression),
    /// (target_address, value)
    /// Stores the value generated by the right Expression
    /// at the Location in memory generated by the left
    /// Expression
    DerefAssignment(Expression, Expression),
    /// Returns the value generated by the given Expression
    Return(Expression),
    /// Simply represents the Evaluation of this single
    /// Expression
    SingleExpression(Expression),
    /// A simple while loop that executes the given
    /// Statements as long as the given Condition is still
    /// evalutating to true
    WhileLoop(Condition, Vec<Statement>),
    /// A simple If-Statement that executes the given
    /// Statements if the given Condition is evalutating to
    /// true
    If(Condition, Vec<Statement>),
}

#[derive(Debug, PartialEq)]
pub struct Function(
    /// The Name of the Function
    pub String,
    /// The Return-Type of the Function
    pub DataType,
    /// The List of Arguments the Function accepts
    pub Vec<(String, DataType)>,
    /// The List of Statements contained in this
    /// Function
    pub Vec<Statement>,
);

impl pretty_print::PrettyPrint for Function {
    fn print(&self, formatter: &mut pretty_print::PrettyFormatter) {
        formatter.print_str("Function:");

        let mut sub = formatter.print_sub();
        sub.print_str(&format!("Name: {:?}", self.0));
        sub.print_str("Params:");
        for tmp in self.2.iter() {
            sub.print_str(&format!("{}: {:?}", tmp.0, tmp.1));
        }
        sub.print_str(&format!("Returns: {:?}", self.1));
        sub.print_str("Body:");

        let mut body = sub.print_sub();
        for tmp in self.3.iter() {
            tmp.print(&mut body);
        }
    }
}

impl pretty_print::PrettyPrint for Statement {
    fn print(&self, formatter: &mut PrettyFormatter) {
        match self {
            Self::WhileLoop(
                Condition {
                    left,
                    right,
                    comparison,
                },
                inner,
            ) => {
                formatter.print_str(&format!("While ({:?} {:?} {:?}):", left, comparison, right));
                let mut inner_scope = formatter.print_sub();
                for tmp in inner.iter() {
                    tmp.print(&mut inner_scope);
                }
            }
            Self::SingleExpression(exp) => {
                exp.print(formatter);
            }
            Self::Assignment(var, exp) => {
                formatter.print_str("Assignment:");
                let mut sub = formatter.print_sub();
                var.print(&mut sub);
                exp.print(&mut sub);
            }
            Self::DerefAssignment(target_exp, value_exp) => {
                formatter.print_str("Deref-Assignment:");

                let mut sub = formatter.print_sub();
                sub.print_str("Target:");
                target_exp.print(&mut sub.print_sub());
                sub.print_str("Value:");
                value_exp.print(&mut sub.print_sub());
            }
            _ => {
                formatter.print_str(&format!("{:?}", self));
            }
        };
    }
}

impl pretty_print::PrettyPrint for Expression {
    fn print(&self, formatter: &mut PrettyFormatter) {
        match self {
            Self::Call(name, vars) => {
                formatter.print_str("Call:");
                let mut sub = formatter.print_sub();

                sub.print_str(&format!("Function: {}", name));
                sub.print_str("Params:");
                let mut params = sub.print_sub();
                for tmp in vars.iter() {
                    tmp.print(&mut params);
                }
            }
            Self::Variable(var) => {
                var.print(formatter);
            }
            Self::Operation(operation, parts) => {
                formatter.print_str(&format!("Operation: {:?}", operation));

                let mut parts_fmt = formatter.print_sub();
                for part in parts.iter() {
                    part.print(&mut parts_fmt);
                }
            }
            _ => {
                formatter.print_str(&format!("{:?}", self));
            }
        };
    }
}

impl pretty_print::PrettyPrint for Variable {
    fn print(&self, formatter: &mut PrettyFormatter) {
        formatter.print_str("Variable:");

        let mut sub = formatter.print_sub();
        sub.print_str(&format!("Name: '{}'", self.name));
        sub.print_str(&format!("Type: {:?}", self.ty));
    }
}

impl Variable {
    pub fn new_str(name: &str, ty: DataType) -> Self {
        Self {
            name: name.to_owned(),
            ty,
        }
    }
}
