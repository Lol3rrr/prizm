/// The basic Datatypes present on the Device
#[derive(Debug, PartialEq, Clone)]
pub enum DataType {
    Void,
    I32,
    U32,
    I16,
    U16,
    Ptr(Box<DataType>),
    Array(Box<DataType>, u32),
}

/// A simple Constant Value
#[derive(Debug, PartialEq)]
pub enum Value {
    I32(i32),
    U32(u32),
    Short(i16),
    UShort(u16),
}

/// The Operations that can be Performed on
/// the Calculator using the Operation-Expression
#[derive(Debug, PartialEq)]
pub enum OP {
    /// Represents Addition
    Add,
    /// Represents Substraction
    Substract,
    /// Represents Multiplication
    Multiply,
    /// Represents Division
    Divide,
}

/// This describes the way two values should
/// be compared
#[derive(Debug, PartialEq)]
pub enum Comparison {
    Equal,
    LessThan,
}

/// Represents a simple Condition where to
/// Expressions are compared using the given
/// Comparison
#[derive(Debug, PartialEq)]
pub struct Condition {
    pub left: Expression,
    pub right: Expression,
    pub comparison: Comparison,
}

/// This represents some kind of Expression that will
/// evaluate to a specific Value which will be stored
/// in the Register R0
#[derive(Debug, PartialEq)]
pub enum Expression {
    /// Some form of Constant Value that won't change
    Constant(Value),
    /// The Value of some Variable in the current Scope
    Variable(String),
    /// The Address of some Variable in the current Scope
    Reference(String),
    /// Loads the Value at the address that is "generated"
    /// by the given Expression
    Dereference(Box<Expression>),
    /// (Root, Offset)
    /// The Root is the starting Address of the Array
    /// The Offset is the Index of the Element in the Array
    Indexed(Box<Expression>, Box<Expression>),
    /// Performs some kind of Mathematical or Logical Operation
    /// like Addition, Multiplication, etc.
    Operation(OP, Vec<Expression>),
    /// Calls the given Function with the given Expressions
    /// as the arguments to the Function
    Call(String, Vec<Expression>),
    /// A simple Nop, that does nothing
    Empty,
}

#[derive(Debug, PartialEq)]
pub enum Statement {
    /// Declares the existence of a Variable with the given
    /// Name and Datatype in the current Scope
    Declaration(String, DataType),
    /// Assigns the value generated by the Expression to the
    /// given Variable
    Assignment(String, Expression),
    /// (target_address, value)
    /// Stores the value generated by the right Expression
    /// at the Location in memory generated by the left
    /// Expression
    DerefAssignment(Expression, Expression),
    /// Returns the value generated by the given Expression
    Return(Expression),
    /// Simply represents the Evaluation of this single
    /// Expression
    SingleExpression(Expression),
    /// A simple while loop that executes the given
    /// Statements as long as the given Condition is still
    /// evalutating to true
    WhileLoop(Condition, Vec<Statement>),
    /// A simple If-Statement that executes the given
    /// Statements if the given Condition is evalutating to
    /// true
    If(Condition, Vec<Statement>),
}

#[derive(Debug, PartialEq)]
pub struct Function(
    /// The Name of the Function
    pub String,
    /// The Return-Type of the Function
    pub DataType,
    /// The List of Arguments the Function accepts
    pub Vec<(String, DataType)>,
    /// The List of Statements contained in this
    /// Function
    pub Vec<Statement>,
);

fn gen_padding(length: u8) -> String {
    let mut result = String::new();

    for _ in 0..(length - 1) {
        result.push('-');
    }
    result.push('>');

    result
}
impl Function {
    pub fn pretty_print(&self) {
        let padding = gen_padding(2);
        let sub_padding = gen_padding(3);

        println!("Function:");
        println!("{}Name: {:?}", padding, self.0);
        println!("{}Params:", padding);
        for tmp in self.2.iter() {
            println!("{}{}: {:?}", sub_padding, tmp.0, tmp.1);
        }
        println!("{}Returns: {:?}", padding, self.1);
        println!("{}Body:", padding);
        for tmp in self.3.iter() {
            tmp.pretty_print(3);
        }
        println!();
    }
}

impl Statement {
    pub fn pretty_print(&self, padding_length: u8) {
        let padding = gen_padding(padding_length);

        match self {
            Self::WhileLoop(
                Condition {
                    left,
                    right,
                    comparison,
                },
                inner,
            ) => {
                println!(
                    "{}While ({:?} {:?} {:?}):",
                    padding, left, comparison, right
                );
                for tmp in inner.iter() {
                    tmp.pretty_print(padding_length + 2);
                }
            }
            _ => {
                println!("{}{:?}", padding, self);
            }
        };
    }
}
